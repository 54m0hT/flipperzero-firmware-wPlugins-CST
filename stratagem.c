#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <input/input.h>
#include <gui/elements.h>
#include <gui/canvas.h>
#include <stdlib.h>

/* generated by fbt from .png files in images folder */
#include <stratagem_icons.h>

int arrowIndex = 0;

typedef struct{
    char name[32];
    int nameLength;
    char arrows[8];
    int arrowCount;
} stratagem;

stratagem test;
uint32_t totaltime = 10000;
uint32_t remainingtime = 10000;

void draw_stratagem(Canvas* canvas, uint8_t y, stratagem* subject){
    int arrowSize = 14; //its square
    int x = 64 - ((subject->arrowCount * arrowSize) / 2) + (arrowSize / 2);
    y -= arrowSize / 2;

    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str_aligned(canvas, 64, y - (arrowSize / 2), AlignCenter, AlignCenter, subject->name);
    for(int i = 0; i < subject->arrowCount; i++){
        switch (subject->arrows[i])
        {
            case 'U':
                if(i <= (arrowIndex+1)){ canvas_draw_icon(canvas, x, y, &I_UpArrow_Filled_14x14); }
                else{ canvas_draw_icon(canvas, x, y, &I_UpArrow_Empty_14x14); }
                break;

            case 'D':
                if(i <= (arrowIndex+1)){ canvas_draw_icon(canvas, x, y, &I_DownArrow_Filled_14x14); }
                else{ canvas_draw_icon(canvas, x, y, &I_DownArrow_Empty_14x14); }
                break;

            case 'L':
                if(i <= (arrowIndex+1)){ canvas_draw_icon(canvas, x, y, &I_LeftArrow_Filled_14x14); }
                else{ canvas_draw_icon(canvas, x, y, &I_LeftArrow_Empty_14x14); }
                break;

            case 'R':
                if(i <= (arrowIndex+1)){ canvas_draw_icon(canvas, x, y, &I_RightArrow_Filled_14x14); }
                else{ canvas_draw_icon(canvas, x, y, &I_RightArrow_Empty_14x14); }
                break;
            
            case 0x00:
                return;
        }
        x += arrowSize;
    }
}

void draw_timer_bar(Canvas* canvas, uint8_t x, uint8_t y, uint8_t width, float progress) {
    furi_assert(canvas);
    furi_assert((progress >= 0.0) && (progress <= 1.0));
    uint8_t height = 9;

    uint8_t progress_length = roundf(progress * (width - 2));

    canvas_set_color(canvas, ColorWhite);
    canvas_draw_box(canvas, x + 1, y + 1, width - 2, height - 2);
    canvas_set_color(canvas, ColorBlack);
    canvas_draw_rframe(canvas, x, y, width, height, 3);

    uint8_t midpoint = x + (width / 2);

    canvas_draw_box(canvas, midpoint - (progress_length / 2), y + 1, progress_length, height - 2);
}

static void draw_callback(Canvas* canvas, void* ctx) {
    UNUSED(ctx);

    canvas_clear(canvas);

    draw_timer_bar(canvas, 2, 53, 124, 0.5);
    draw_stratagem(canvas, 30, &test);
}

static void input_callback(InputEvent* input_event, void* ctx) {
    furi_assert(ctx);
    FuriMessageQueue* event_queue = ctx;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

static void timer_callback(void* ctx) {
    furi_assert(ctx);
    UNUSED(ctx);
}

int32_t stratagem_app(void* p) {
    UNUSED(p);

    InputEvent event;
    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, draw_callback, NULL);
    view_port_input_callback_set(view_port, input_callback, event_queue);

    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    FuriTimer* timer = furi_timer_alloc(timer_callback, FuriTimerTypePeriodic, NULL);
    furi_timer_start(timer, (uint32_t)furi_kernel_get_tick_frequency() / 100);

    bool running = true;

    view_port_update(view_port);

    memcpy(test.name, "Eagle 500kg bomb", 17);
    test.nameLength = 5;
    memcpy(test.arrows, "URDDD", 6);
    test.arrowCount = 6;

    while(running) {
        furi_check(furi_message_queue_get(event_queue, &event, FuriWaitForever) == FuriStatusOk);
        view_port_update(view_port);
        if(event.type == InputTypePress) {
            if(event.key == InputKeyBack) { running = false; }
        }
    }

    furi_message_queue_free(event_queue);
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_record_close(RECORD_GUI);
    return 0;
}
