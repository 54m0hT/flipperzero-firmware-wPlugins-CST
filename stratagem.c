#include <furi.h>
#include <furi_hal.h>
#include <gui/gui.h>
#include <input/input.h>
#include <gui/elements.h>
#include <gui/canvas.h>
#include <stdlib.h>
#include "tinyfont.h"
/* generated by fbt from .png files in images folder */
#include <stratagem_icons.h>

int arrowIndex = 0;

typedef struct{
    char name[24];
    char arrows[12];
} stratagem;

typedef struct{
    char name[32];
    int groupID;
    stratagem stratagems[16];
    int stratagemCount;
} group;

group groups[7] = {};
stratagem* currentStratagem = 0;

int32_t totaltime = 1000;
int32_t remainingtime = 1000;

char strTime[16];

void initStratagems(){
    groups[0].groupID = 0;
    groups[0].stratagemCount = 3;
    memcpy(groups[0].name, "Mission", 8);

    memcpy(groups[0].stratagems[0].name, "Reinforce", 10);
    memcpy(groups[0].stratagems[0].arrows, "UDRLU", 6);

    memcpy(groups[0].stratagems[1].name, "SOS Beacon", 11);
    memcpy(groups[0].stratagems[1].arrows, "UDLR", 5);

    memcpy(groups[0].stratagems[2].name, "Resupply", 9);
    memcpy(groups[0].stratagems[2].arrows, "DDUR", 5);

    groups[1].groupID = 1;
    groups[1].stratagemCount = 8;
    memcpy(groups[1].name, "Offensive: Eagle", 17);

    memcpy(groups[1].stratagems[0].name, "Eagle Rearm", 12);
    memcpy(groups[1].stratagems[0].arrows, "UULUR", 6);

    memcpy(groups[1].stratagems[1].name, "Eagle Strafing Run", 19);
    memcpy(groups[1].stratagems[1].arrows, "URR", 4);

    memcpy(groups[1].stratagems[2].name, "Eagle Airstrike", 16);
    memcpy(groups[1].stratagems[2].arrows, "URDR", 5);

    memcpy(groups[1].stratagems[3].name, "Eagle Cluster Bomb", 19);
    memcpy(groups[1].stratagems[3].arrows, "URDDR", 6);

    memcpy(groups[1].stratagems[4].name, "Eagle Napalm Strike", 20);
    memcpy(groups[1].stratagems[4].arrows, "URDU", 5);

    memcpy(groups[1].stratagems[5].name, "Eagle Smoke Strike", 19);
    memcpy(groups[1].stratagems[5].arrows, "URUD", 5);

    memcpy(groups[1].stratagems[6].name, "Eagle 110MM Rockets", 20);
    memcpy(groups[1].stratagems[6].arrows, "URUL", 5);

    memcpy(groups[1].stratagems[7].name, "Eagle 500kg Bomb", 17);
    memcpy(groups[1].stratagems[7].arrows, "URDDD", 6);

    groups[2].groupID = 2;
    groups[2].stratagemCount = 15;
    memcpy(groups[2].name, "Supply: Weapons", 16);

    memcpy(groups[2].stratagems[0].name, "RL-77 Rocket Launcher", 22);
    memcpy(groups[2].stratagems[0].arrows, "DUULR", 6);

    memcpy(groups[2].stratagems[1].name, "AC-8 Autocannon", 16);
    memcpy(groups[2].stratagems[1].arrows, "DLDUUR", 7);

    memcpy(groups[2].stratagems[2].name, "EAT-17 Anti-Tank", 17);
    memcpy(groups[2].stratagems[2].arrows, "DDLUR", 6);

    memcpy(groups[2].stratagems[3].name, "FLAM-40 Flamethrower", 21);
    memcpy(groups[2].stratagems[3].arrows, "DLDRL", 6);

    memcpy(groups[2].stratagems[4].name, "LAS-98 Laser Cannon", 20);
    memcpy(groups[2].stratagems[4].arrows, "DLDUL", 6);

    memcpy(groups[2].stratagems[5].name, "M-105 Stalwart", 15);
    memcpy(groups[2].stratagems[5].arrows, "DLDUUL", 7);

    memcpy(groups[2].stratagems[6].name, "MG-43 Machine Gun", 18);
    memcpy(groups[2].stratagems[6].arrows, "DLDUR", 6);

    memcpy(groups[2].stratagems[7].name, "ARC-3 Arc Thrower", 18);
    memcpy(groups[2].stratagems[7].arrows, "DRDULL", 7);

    memcpy(groups[2].stratagems[8].name, "GL-21 Grenade Launcher", 18);
    memcpy(groups[2].stratagems[8].arrows, "DLULD", 6);

    memcpy(groups[2].stratagems[9].name, "APW-1 Anti-Mat Rifle", 21);
    memcpy(groups[2].stratagems[9].arrows, "DLRUD", 6);

    memcpy(groups[2].stratagems[10].name, "RS-422 Railgun", 15);
    memcpy(groups[2].stratagems[10].arrows, "DRDULR", 7);

    memcpy(groups[2].stratagems[11].name, "GR-8 Recoilless Rifle", 22);
    memcpy(groups[2].stratagems[11].arrows, "DLRRL", 6);

    memcpy(groups[2].stratagems[12].name, "FAF-14 Spear", 13);
    memcpy(groups[2].stratagems[12].arrows, "DDUDD", 6);

    memcpy(groups[2].stratagems[13].name, "LAS-99 Quasar Cannon", 21);
    memcpy(groups[2].stratagems[13].arrows, "DDULR", 6);

    memcpy(groups[2].stratagems[14].name, "MG-206 Machine Gun", 19);
    memcpy(groups[2].stratagems[14].arrows, "DLUDD", 6);

    groups[3].groupID = 3;
    groups[3].stratagemCount = 11;
    memcpy(groups[3].name, "Offensive: Orbital Strikes", 27);

    memcpy(groups[3].stratagems[0].name, "O. Precision Strike", 20);
    memcpy(groups[3].stratagems[0].arrows, "RRU", 4);

    memcpy(groups[3].stratagems[1].name, "O. Airbust Strike", 18);
    memcpy(groups[3].stratagems[1].arrows, "RRR", 4);

    memcpy(groups[3].stratagems[2].name, "O. 120MM HE Barrage", 20);
    memcpy(groups[3].stratagems[2].arrows, "RDDLDRDD", 9);

    memcpy(groups[3].stratagems[3].name, "O. 380MM HE Barrage", 20);
    memcpy(groups[3].stratagems[3].arrows, "RDUULDD", 8);

    memcpy(groups[3].stratagems[4].name, "O. Walking Barrage", 19);
    memcpy(groups[3].stratagems[4].arrows, "RDRDRD", 7);

    memcpy(groups[3].stratagems[5].name, "Orbital Laser", 14);
    memcpy(groups[3].stratagems[5].arrows, "RDURD", 6);

    memcpy(groups[3].stratagems[6].name, "O. Railcannon Strike", 21);
    memcpy(groups[3].stratagems[6].arrows, "RUDDR", 6);

    memcpy(groups[3].stratagems[7].name, "O. Gatling Barrage", 19);
    memcpy(groups[3].stratagems[7].arrows, "RDLUU", 6);

    memcpy(groups[3].stratagems[8].name, "O. Gas Strike", 14);
    memcpy(groups[3].stratagems[8].arrows, "RRDR", 5);

    memcpy(groups[3].stratagems[9].name, "O. EMS Strike", 14);
    memcpy(groups[3].stratagems[9].arrows, "RRLD", 5);

    memcpy(groups[3].stratagems[10].name, "O. Smoke Strike", 16);
    memcpy(groups[3].stratagems[10].arrows, "RRDU", 5);

    groups[4].groupID = 4;
    groups[4].stratagemCount = 7;
    memcpy(groups[4].name, "Supply: Extras", 15);

    groups[5].groupID = 5;
    groups[5].stratagemCount = 11;
    memcpy(groups[5].name, "Defensive", 10);
}

void draw_stratagem(Canvas* canvas, uint8_t y){
    int arrowSize = 14; //its square
    int x = 64 - (((int)strlen(currentStratagem->arrows) * arrowSize) / 2);
    y -= arrowSize / 2;

    canvas_set_font(canvas, FontPrimary);
    canvas_draw_str_aligned(canvas, 64, y - (arrowSize * 0.5), AlignCenter, AlignCenter, currentStratagem->name);

    for(int i = 0; i < (int)strlen(currentStratagem->arrows); i++){
        switch (currentStratagem->arrows[i])
        {
            case 'U':
                if(arrowIndex > i){ canvas_draw_icon(canvas, x, y, &I_UpArrow_Filled_14x14); }
                else{ canvas_draw_icon(canvas, x, y, &I_UpArrow_Empty_14x14); }
                break;

            case 'D':
                if(arrowIndex > i){ canvas_draw_icon(canvas, x, y, &I_DownArrow_Filled_14x14); }
                else{ canvas_draw_icon(canvas, x, y, &I_DownArrow_Empty_14x14); }
                break;

            case 'L':
                if(arrowIndex > i){ canvas_draw_icon(canvas, x, y, &I_LeftArrow_Filled_14x14); }
                else{ canvas_draw_icon(canvas, x, y, &I_LeftArrow_Empty_14x14); }
                break;

            case 'R':
                if(arrowIndex > i){ canvas_draw_icon(canvas, x, y, &I_RightArrow_Filled_14x14); }
                else{ canvas_draw_icon(canvas, x, y, &I_RightArrow_Empty_14x14); }
                break;
            
            case 0x00:
                return;
        }
        x += arrowSize;
    }
}

void draw_timer_bar(Canvas* canvas, uint8_t x, uint8_t y, uint8_t width, float progress) {
    furi_assert(canvas);
    furi_assert((progress >= 0.0) && (progress <= 1.0));
    uint8_t height = 9;

    uint8_t progress_length = roundf(progress * (width - 2));

    canvas_set_color(canvas, ColorWhite);
    canvas_draw_box(canvas, x + 1, y + 1, width - 2, height - 2);
    canvas_set_color(canvas, ColorBlack);
    canvas_draw_rframe(canvas, x, y, width, height, 3);

    uint8_t midpoint = x + (width / 2);

    canvas_draw_box(canvas, midpoint - (progress_length / 2), y + 1, progress_length, height - 2);
}

static void draw_callback(Canvas* canvas, void* ctx) {
    UNUSED(ctx);

    canvas_clear(canvas);

    draw_stratagem(canvas, 30);

    float remPerc = (float)((float)remainingtime / (float)totaltime);
    draw_timer_bar(canvas, 2, 53, 124, remPerc);
}

static void input_callback(InputEvent* input_event, void* ctx) {
    furi_assert(ctx);
    FuriMessageQueue* event_queue = ctx;
    furi_message_queue_put(event_queue, input_event, 100);
}

static void timer_callback(void* ctx) {
    furi_assert(ctx);
    UNUSED(ctx);
    if(remainingtime <= 0){ 
        remainingtime = 0;
        return; 
    }
    remainingtime--;
}

static void handleKeyPress(InputKey key){
    bool fail = false;

    if(key == InputKeyUp){
        if(currentStratagem->arrows[arrowIndex] == 'U'){
            arrowIndex++;
        }
        else{ fail = true; }
    }
    if(key == InputKeyDown){
        if(currentStratagem->arrows[arrowIndex] == 'D'){
            arrowIndex++;
        }
        else{ fail = true; }
    }
    if(key == InputKeyLeft){
        if(currentStratagem->arrows[arrowIndex] == 'L'){
            arrowIndex++;
        }
        else{ fail = true; }
    }
    if(key == InputKeyRight){
        if(currentStratagem->arrows[arrowIndex] == 'R'){
            arrowIndex++;
        }
        else{ fail = true; }
    }

    if(fail){
        remainingtime -= 100;
        arrowIndex = 0;
    }

    if(arrowIndex == ((int)strlen(currentStratagem->arrows))){
        arrowIndex = 0;
        remainingtime += 100;
    }
}

int32_t stratagem_app(void* p) {
    UNUSED(p);

    initStratagems();

    InputEvent event;
    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, draw_callback, NULL);
    view_port_input_callback_set(view_port, input_callback, event_queue);

    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    FuriTimer* timer = furi_timer_alloc(timer_callback, FuriTimerTypePeriodic, NULL);
    furi_timer_start(timer, (uint32_t)furi_kernel_get_tick_frequency() / 100);

    bool running = true;

    view_port_update(view_port);

    currentStratagem = &(groups[3].stratagems[4]);

    while(running) {
        FuriStatus event_status = furi_message_queue_get(event_queue, &event, 100);
        view_port_update(view_port);
        if(!(event_status == FuriStatusOk)){ continue; }
        if(event.type == InputTypePress) {
            if(event.key == InputKeyUp || event.key == InputKeyDown || event.key == InputKeyLeft || event.key == InputKeyRight){
                handleKeyPress(event.key);
            }
            if(event.key == InputKeyBack) { running = false; }
        }
    }

    furi_timer_stop(timer);
    furi_timer_free(timer);
    furi_message_queue_free(event_queue);
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_record_close(RECORD_GUI);
    return 0;
}
